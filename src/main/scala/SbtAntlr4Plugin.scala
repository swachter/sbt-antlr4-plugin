package eu.swdef.sbt.antlr4

import scala.collection.JavaConverters._
import sbt._
import Keys._
import org.antlr.v4.Tool
import java.nio.file.{Path => JPath}
import org.antlr.v4.tool.ast.GrammarRootAST
import org.antlr.v4.tool.{BuildDependencyGenerator, Grammar}

object SbtAntlr4Plugin extends Plugin {

  case class Antlr4Params(
    grammarEncoding: String = "UTF-8",
    generateVisitor: Boolean = false,
    generateListener: Boolean = false,
    args: Array[String] = Array()
  )

  object Antlr4Keys {

    val srcDirs = SettingKey[Seq[File]]("antlr-source-dirs", "source directories where grammar files are looked for")

    val grammarFiles = TaskKey[Seq[(File,JPath)]]("antlr-grammar-files", "determines the grammar files that are processed together with their relative paths to the source roots")

    val generateDir = SettingKey[File]("antlr-generate-dir", "(temporary) output directory for all files generated by Antlr")

    val defaultParams = SettingKey[Antlr4Params]("antlr-default-params", "default parameters for Antlr")
    val grammarParams = SettingKey[Map[String, Antlr4Params]]("antlr-grammar-params", "grammar specific parameters for Antlr (grammarFileName -> params)")

    val generate = TaskKey[Seq[JPath]]("antlr-generate", "generate all files by calling Antlr")
    val copyJavaSources = TaskKey[Seq[File]]("antlr-copy-java-sources", "copies all generated java sources")
    val copyTokenFiles = TaskKey[Seq[File]]("antlr-copy-tokens", "copies all generated token files")

    val dependency = SettingKey[ModuleID]("antlr-dependency", "compile time dependency that is added for Antlr")
  }

  /**
   * Default settings for the plugin specific keys.
   */
  lazy val antlr4DefaultSettings: Seq[Setting[_]] = Seq(

    // directories where grammar files are looked for
    Antlr4Keys.srcDirs <<= (sourceDirectory in Compile) {
      d => Seq(d / "java", d / "scala", d / "antlr")
    },

    // temporary directory for all generated files
    Antlr4Keys.generateDir <<= (target) {
      _ / "antlr.tmp"
    },

    // default Antlr parameters
    Antlr4Keys.defaultParams := Antlr4Params(),
    // grammar specific Antlr parameters
    Antlr4Keys.grammarParams := Map(),

    // determines the grammer files and their relative paths in their source directory
    Antlr4Keys.grammarFiles <<= (streams, Antlr4Keys.srcDirs) map {
      (taskStreams, srcDirs) => grammarFiles(taskStreams, srcDirs)
    },

    // generate all files by calling Antlr
    Antlr4Keys.generate <<= (streams, Antlr4Keys.defaultParams, Antlr4Keys.grammarParams, Antlr4Keys.grammarFiles, Antlr4Keys.generateDir, cacheDirectory) map {
      (taskStreams, defaultParams, grammarParams, grammarFiles, outDir, cacheDir) => generate(taskStreams, defaultParams, grammarParams, grammarFiles, outDir, cacheDir)
    },

    // copies generated Java files
    Antlr4Keys.copyJavaSources <<= (streams, Antlr4Keys.generate, Antlr4Keys.generateDir, sourceManaged in Compile) map {
      (taskStreams, generatedFiles, from, to) => copyFiles(taskStreams, generatedFiles, from, to / "java", ".java")
    },
    // copies generated token files
    Antlr4Keys.copyTokenFiles <<= (streams, Antlr4Keys.generate, Antlr4Keys.generateDir, resourceManaged in Compile) map {
      (taskStreams, generatedFiles, from, to) => copyFiles(taskStreams, generatedFiles, from, to, ".tokens")
    },

    // added compile time dependency
    Antlr4Keys.dependency := "org.antlr" % "antlr4" % "4.0"
  )

  /**
   * Settings that integrate the plugin into the build.
   */
  lazy val antlr4ProjectSettings: Seq[Setting[_]] = Seq(
    sourceGenerators in Compile <+= Antlr4Keys.copyJavaSources,
    resourceGenerators in Compile <+= Antlr4Keys.copyTokenFiles,
    libraryDependencies <+= Antlr4Keys.dependency
  )

  /**
   * Complete plugin settings.
   */
  lazy val antlr4Settings = antlr4DefaultSettings ++ antlr4ProjectSettings

  /**
   * Finds grammar files in a sequence of source directories and returns a sequence of the found grammar files together
   * with the relative path from the source directory to the grammar.
   */
  private def grammarFiles(taskStreams: TaskStreams, srcDirs: Seq[File]): Seq[(File, JPath)] = {
    taskStreams.log.info("Antlr4 - source dirs: " + srcDirs)
    for {
      d <- srcDirs
      g <- (d ** ("*.g4")).get
    } yield {
      val relPath = d.toPath.relativize(g.toPath.getParent)
      (g, relPath)
    } 
  }

  /**
   * Generates the output for a sequence of grammar files.
   *
   * @param taskStreams
   * @param defaultParams
   * @param grammarParams
   * @param grammarFiles
   * @param outDir
   * @param cacheDir
   * @return
   */
  private def generate(taskStreams: TaskStreams, defaultParams: Antlr4Params, grammarParams: Map[String, Antlr4Params], grammarFiles: Seq[(File, JPath)], outDir: File, cacheDir: File): Seq[JPath] = {
    taskStreams.log.info("Antlr4 - generate; version: " + Tool.VERSION)
    // Antlr may be called several times because different output directories and parameters may be used.
    // -> group the grammar files with respect to their relative paths (i.e. output directories) and used Antlr parameters
    val rrr: Seq[Seq[JPath]] = for {
      relPath <- grammarFiles.map(_._2).distinct
    } yield {
      val pkgDir = outDir.toPath.resolve(relPath).toFile
      val pkg = relPath.toString().replaceAllLiterally(relPath.getFileSystem.getSeparator, ".")
      taskStreams.log.info("Antlr4 - packageDir: " + pkgDir + "; package: " + pkg)
      pkgDir.mkdirs
      val rr: Seq[Seq[JPath]] = for {
        params <- grammarFiles.filter(_._2 == relPath).map(t => getParams(t._1, defaultParams, grammarParams)).distinct
      } yield {
        taskStreams.log.info("Antlr4 - params: " + params)
        // select all grammar files for a specific package and specific parameters
        val files: Seq[File] = grammarFiles.filter(t => t._2 == relPath && params == getParams(t._1, defaultParams, grammarParams)).map(_._1)
        generate(taskStreams, files, params, pkgDir, pkg).map(f => outDir.toPath.relativize(f.toPath))
      }
      rr.flatten
    }
    rrr.flatten
  }

  private def getParams(g: File, defaultParams: Antlr4Params, grammarParams: Map[String, Antlr4Params]): Antlr4Params = {
    grammarParams.getOrElse(g.getName, defaultParams)
  }

  /**
   * Generates the output for grammar files that belong to the same package and use the same Antlr parameters.
   *
   * @param taskStreams
   * @param grammarFiles
   * @param params
   * @param pkgDir
   * @param pkg
   * @return A sequence of all output files.
   */
  private def generate(taskStreams: TaskStreams, grammarFiles: Seq[File], params: Antlr4Params, pkgDir: File, pkg: String): Seq[File] = {
    val tool = new AntlrTool(params.args, pkgDir)
    tool.grammarEncoding = params.grammarEncoding
    tool.gen_visitor = params.generateVisitor
    tool.gen_listener = params.generateListener
    if (!pkg.isEmpty) {
      tool.genPackage = pkg
    }
    for {
      grammarFile <- grammarFiles
    } {
      tool.addGrammarFile(grammarFile)
    }

    // Grammars are sorted because a grammar may depend on other grammars. Dependant grammars are processed later.
    val grammars: Seq[Grammar] = tool.sortedGrammars
    val grammarInfos: Seq[GrammarInfo] = grammars.map(tool.grammarInfo(_))

    for {
      grammerInfo <- grammarInfos
    } {
      val upToDate = grammerInfo.isUpToDate
      taskStreams.log.info("Antlr4 - grammar: " + grammerInfo.grammar.fileName + "; upToDate: " + upToDate)
      grammerInfo.input.foreach(f => taskStreams.log.info("Antlr4 - input : " + f))
      grammerInfo.output.foreach(f => taskStreams.log.info("Antlr4 - output: " + f))
      if (!upToDate) {
        tool.process(grammerInfo.grammar, true)
      }
    }

    grammarInfos.map(_.output).flatten
  }

  private def copyFiles(taskStreams: TaskStreams, paths: Seq[JPath], from: File, to: File, suffix: String): Seq[File] = {
    for {
      p <- paths.filter(_.toString().endsWith(suffix))
    } yield {
      val f = from.toPath.resolve(p).toFile
      val t = to.toPath.resolve(p).toFile
      IO.copyFile(f, t, true)
      t
    }
  }

  private case class GrammarInfo(grammar: Grammar, input: Seq[File], output: Seq[File]) {
    def isUpToDate: Boolean = {
      output.forall(_.exists) && input.map(_.lastModified).max < output.map(_.lastModified).min
    }
  }

  /**
   * Extends the Antlr Tool class to support better non-commandline (i.e. embedded) usage.
   *
   * @param args
   * @param pkgDir
   */
  private class AntlrTool(args: Array[String], val pkgDir: File) extends Tool(args) {

    def addGrammarFile(f: File) {
      grammarFiles.add(f.getAbsolutePath)
    }

    // handleArgs is called in the super class constructor
    // -> the outputDirectory must be set before because it is processed in super.handleArgs()
    override def handleArgs(): Unit = {
      outputDirectory = pkgDir.getAbsolutePath
      super.handleArgs()
    }

    def sortedGrammars: Seq[Grammar] = {
      val asts: Seq[GrammarRootAST] = sortGrammarByTokenVocab(grammarFiles).asScala
      asts.map(ast => {
        val grammar = createGrammar(ast)
        grammar.fileName = ast.fileName
        grammar
      })
    }

    def grammarInfo(grammar: Grammar): GrammarInfo = {
      val bdg = new BuildDependencyGenerator(this, grammar)
      val grammarInput = Seq(new File(grammar.fileName))
      val dep = bdg.getDependenciesFileList
      val input = if (dep == null) {
        grammarInput
      } else {
        grammarInput ++ dep.asScala
      }
      GrammarInfo(grammar, input, bdg.getGeneratedFileList.asScala)
    }
  }
}